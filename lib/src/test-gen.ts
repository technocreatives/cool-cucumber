import {
  Envelope,
  GherkinDocument,
  Pickle,
  PickleStep,
  PickleTable,
} from "@cucumber/messages";

export default function featureToJestTest(
  messages: readonly Envelope[]
): string {
  const documents = messages.filter((message) => message.gherkinDocument);
  if (documents.length !== 1) {
    throw new Error(
      `Expected exactly 1 gherkin document from 1 file, got ${documents.length}`
    );
  }
  const ast = documents[0].gherkinDocument as GherkinDocument;
  const feature = ast.feature;
  if (!feature) {
    throw new Error(`Expected a feature to be in gherkin document`);
  }

  const pickles = messages
    .filter((message) => message.pickle)
    .map((message) => message.pickle) as Pickle[];
  const tests = pickles.map((pickle) => pickleToTest(pickle, ast));

  const block = feature.tags.find((tag) => tag.name === "@skip") ? "xdescribe" : "describe";

  return `// intermediate code generated by cool-cucumber

    const supportCodeLibraryBuilder = require('@cucumber/cucumber/lib/support_code_library_builder').default;
    const cucumberEnv = supportCodeLibraryBuilder.finalize();
    const allKnownSteps = cucumberEnv.stepDefinitions.map(x => \`'\${x.pattern}'\`).join(", ");

    ${block}(${JSON.stringify(feature.name)}, () => {
      ${tests.join("\n")}
    })
  `;
}

function pickleToTest(pickle: Pickle, ast: GherkinDocument): string {
  const steps = pickle.steps.map((step) => callSteps(step, ast));
  const test = pickle.tags.find((tag) => tag.name === "@skip") ? "xtest" : "test";

  return `
    // tags: ${pickle.tags.join(", ")}
    ${test}(${JSON.stringify(pickle.name)}, async () => {
      ${steps.join("\n")}
    });
  `;
}

function callSteps(step: PickleStep, ast: GherkinDocument): string {
  const data = dataTableToMap(step.argument?.dataTable);
  const source = step.astNodeIds.map(id => {
    const node = nodeFromId(ast, id);
    const location = node ? `${node.location.line}:${node.location.column}` : ""
    return `\tat ${ast.uri}:${location}`
  })

  return `
    await (async () => {
      const stepText = ${JSON.stringify(step.text)};
      const step = cucumberEnv.stepDefinitions.find((def) => {
        return def.matchesStepName(stepText);
      });
      if (!step) {
        const error = new Error(\`No definition found for step '\${stepText}', I only know these: \${allKnownSteps}\`);
        error.stack = ${JSON.stringify(source.join('\n'))};
        throw error;
      }

      const expression = step.expression?.match(stepText)
      const data = ${JSON.stringify(data)};
      const args = [
        ...(expression || []).map(x => x.getValue()),
        ...(data.length ? [data] : [])
      ];
      await step.code.apply(cucumberEnv.world, args);
    })();
  `;
}

function dataTableToMap(table: PickleTable | undefined): Array<Record<string, string>> {
  const header = table?.rows[0];
  if (!header) { return []; }

  const fields = header.cells.map((cell) => cell.value);
  return table.rows
    .slice(1)
    .map((row) =>
      Object.fromEntries(
        row.cells.map((cell, idx) => [fields[idx], cell.value])
      )
    );
}

function nodeFromId(ast: GherkinDocument, id: string) {
  const allIdThings = ast.feature?.children.flatMap(child => [
    ...child.background?.steps ?? [],
    ...child.scenario?.steps ?? [],
    ...child.rule?.children.flatMap(x => [
      ...x.background?.steps ?? [],
      ...x.scenario?.steps ?? []
    ]) ?? []
  ]) ?? [];

  return allIdThings.find((thing) => thing.id === id);
}
